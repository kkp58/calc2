{% extends "base.html" %}
{% block content %}
<!--<!DOCTYPE html>
<html lang="en">-->
<head>
    <meta charset="UTF-8">
    <title>AAA Testing</title>
    <link rel="stylesheet" href="../static/css/article.css">
    <script src="https://kit.fontawesome.com/86aca87940.js" crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
</head>
<!--<body id="page">
<section id="header">
    <nav>
        <a href="../index.html"><img src="../images/logo1.png" alt=""></a>
        <div class="nav-links" id="navLinks">
            <i class="fas fa-times" onclick="hideMenu()"></i>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../history.html">History</a></li>
                <li><a href="../concept.html">Concepts</a></li>
                <li><a href="pylintAndOthers.html">Pylint & Terms</a></li>
                <li><a href="AAATesting.html">AAA Testing</a></li>
                <li><a href="oops.html">OOPS</a></li>
                <li><a href="design.html">Design Patterns</a></li>

            </ul>
        </div>
        <i class="fas fa-bars" onclick="showMenu()"></i>
    </nav>
</section>-->
<section id="aaa">
    <div id="testing" class="card">
        <h2>Importance of Testing -</h2>
        <p>
            Test needs to be written to check that any procedure written, functions the way it should. There are
            different types of tests such as unit tests, integration tests, or end-to-end tests, but all of them do the
            same basic thing: try it and report PASS or FAIL. Testing is important, so we make sure that only the best
            product reaches the end-user. If any problems persist, they should ideally be taken care of earlier on, so
            that they don’t show up when the final version is sent out. The main purpose behind this is to check that
            all the individual parts are working as intended. A unit is known as the smallest possible component of
            software that can be tested. The entire system will only be able to work well if the individual parts are
            working well. Some of the benefits are that the process becomes agile, improves code quality, software bugs
            can be found at an early stage which in turn helps in increasing efficiency, reducing downtime, costs.
            Debugging process gets easier. <br><br>
            <b>AAA Testing</b> - <br>
            To write good tests - there is simple but powerful pattern called AAA Testing which stands for Arrange - Act
            - Assert <br>
        <ol>
            <li><b>Arrange</b> - This step should set up the test case. Like if the test requires any objects or special
                settings, need to prep a database or log into a web app. All those operations are handled here.
            </li>
            <li><b>Act</b> - Act on the target behavior. Act steps should cover the main thing to be tested. This could
                be
                calling a function or method, calling a REST API, or interacting with a web page. Here the actions are
                focused on the target behavior.
            </li>
            <li><b>Assert</b> - expected outcomes. Assert steps verify the goodness or badness of the response from the
                Act
                step. Sometimes, assertions are as simple as checking numeric or string values. Other times, they may
                require checking multiple facets of a system. It will ultimately determine if the test passes or fails.
            </li>
        </ol>
        <br>
        We will see a small tutorial for calculator program to apply the Arrange-Act-Assert pattern in Python using
        pytest. Pytest is the framework to test programs. <br>
        <code>
            def test_calculation_division(self):<br>
            &emsp; &emsp;"""testing that our calculator has a static method for division"""<br>
            &emsp; &emsp;#Arrange <br>
            &emsp; &emsp;mynumbers = (1.0, 2.0, 0.0)<br>
            &emsp; &emsp;# Act <br>
            &emsp; &emsp;self.my_set_up(mynumbers) <br>
            &emsp; &emsp;#Assert <br>
            &emsp; &emsp;assert self.calc.get_result() == 0.5 <br>
            &emsp; &emsp;#After we get result 0.5, it is divided by 0, it should throw ZeroDivisionError <br>
            &emsp; &emsp;assert self.assertRaises(ZeroDivisionError)
        </code> <br>
        So in the test_calculation_division method we have used the AAA pattern to test it. In this example we are using
        unit testing and so it is imported. <br> <br>
        <ul>
            <li>The first step - Arrange step has variable mynumbers where tuple is stored to do the division test.</li>
            <li> The Act step calls the ‘my_set_up’ method using the “mynumbers” variable. Also “my_set_up” uses the
                Division
                class to divide numbers. We are using self in that and it has instance attribute self.calc which stores
                the
                result
            </li>
            <li>The Assert step uses self.calc and verifies if the answer is correct or not using the “assert” keyword.
                Note for this example we have two assert statements as we want to check what happens if the number is
                divided by zero. After we get result 0.5, it is divided by zero and throws division error
            </li>
        </ul>
        </p>
    </div>
    <div id="data" class="card">
        <h2>How to use external data for testing -</h2>
        <p>
            In the real world, we would not be dealing with few numbers to test any program. It would be
            thousands and thousands of records. Most of the time data would be in raw format. It could be csv files,
            plain text separated by some delimiter such as tab, comma, semi-colon. Python has a built-in library to read
            csv files but a library called pandas does the great job. Pandas can read, write, manipulate csv files,
            Excel files and others too.
            <ul>
        <li>Import the pandas library.</li>
            <li>It reads the csv file using ‘read_csv’ syntax.</li>
        <li>First open the file, try to print it out to make sure the data looks good using python code. </li>
            <li> To get the data
                in tabular format we use Dataframes that are the pandas data type. </li>
            <li> Correct file name and path should be
                given to read_csv syntax. Any csv file mentioned there, would first check in ‘current working directory’ </li>
        <li>While loading the file, it is done in two ways, either using absolute path or relative path. </li>

           <li>In relative paths, typically the file will be in a subdirectory of the working directory and the path will
        not start with a drive specifier, e.g. (data/test_file.csv). </li>
            <li>An <b>absolute path</b> is the complete path from the base of your file system to the file that you want to load,
            e.g. c:/Documents/Tom/data/test_file.csv. </li>
    </ul>
        Here we would show a little tutorial for our calculator program on how to use external data using CSV file. (The whole
        code is present in the repo, mentioned in the footer). <br><br>
        <code>
            with open("allFunctionsResults.txt", "w", encoding='utf-8') as results:
        </code>
    The above code makes the new file and opens up, "w" means it writes and 'encoding' needs to be mentioned in order to
        get the data in correct format.
        <br><br>
<code>
    test_data = pd.read_csv(absolutepath("tests/test_data/addition.csv"))
</code>
        This 'test_data' dataframe reads the csv file we mentioned with pandas.
        <br><br>
        <code>
            for record, row in test_data.iterrows(): <br>
            &emsp; &emsp;add = Addition((row['Value 1'], row['Value 2']))
        </code>
        The above code will iterate through each row of the dataframe and will take one at a time. 'Addition' class is called to do
        the add operation.
        <br><br>
        To write into the file, '.write' is used as shown below
        <code>
            results.write('Record Value 1, Value 2, Result \n')
        </code>

        </p>
    </div>
</section>

</body>
{% endblock %}
<!--
</html>-->
